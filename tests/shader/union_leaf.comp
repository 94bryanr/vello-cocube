// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense

// The main phase for the bbox union computation

#version 450

#define LG_N_SEQ 3
#define N_SEQ (1 << LG_N_SEQ)
#define LG_WG_SIZE 6
#define WG_SIZE (1 << LG_WG_SIZE)
#define PART_SIZE (WG_SIZE * N_SEQ)

layout(local_size_x = WG_SIZE, local_size_y = 1) in;

// The bicyclic monoid
struct Bic {
    uint a;
    uint b;
};

Bic bic_combine(Bic x, Bic y) {
    uint m = min(x.b, y.a);
    return Bic(x.a + y.a - m, x.b + y.b - m);
}

// Node type values
#define OPEN_PAREN 0
#define CLOSE_PAREN 1

struct Node {
    uint node_type;
    vec4 bbox;
}

#define BBOX_IDENTITY vec4(1e9, 1e9, -1e9, -1e9)

vec4 bbox_union(vec4 a, vec4 b) {
    return vec4(min(a.xy, b.xy), max(a.zw, b.zw));
}

layout(binding = 0) readonly buffer InBuf {
    Node[] inbuf;
};

layout(binding = 1) readonly buffer BicBuf {
    Bic[] bicbuf;
};

layout(binding = 2) readonly buffer StackBuf {
    vec4[] stack;
};

layout(binding = 3) buffer OutBuf {
    vec4[] outbuf;
};

shared Bic sh_bic[WG_SIZE * 2 - 2];
shared vec4 sh_stack[WG_SIZE];
shared vec4 sh_bbox[WG_SIZE * 2 - 2];

// Note to self: we'll want to put the bboxes in here too.
// This is adapted directly from the stack monoid impl.
// Return value is reference within partition if >= 0,
// otherwise reference to stack.
uint search_link(inout Bic bic) {
    uint ix = gl_LocalInvocationID.x;
    uint j = 0;
    while (j < LG_WG_SIZE) {
        uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
        if (((ix >> j) & 1) != 0) {
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b > 0) {
                break;
            }
            bic = test;
            ix -= 1u << j;
        }
        j++;
    }
    if (ix > 0) {
        while (j > 0) {
            j--;
            uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b == 0) {
                bic = test;
                ix -= 1u << j;
            }
        }
    }
    // ix is the smallest value such that reduce(ix..th).b == 0
    if (ix > 0) {
        return ix - 1;
    } else {
        return ~0u - bic.a;
    }
}

void main() {
    uint th = gl_LocalInvocationID.x;
    // materialize stack snapshot as of the start of this partition
    Bic bic = Bic(0, 0);
    if (th < gl_WorkGroupID.x) {
        bic = bicbuf[th];
    }
    sh_bic[th] = bic;
    for (uint i = 0; i < LG_WG_SIZE; i++) {
        barrier();
        if (th + (1u << i) < WG_SIZE) {
            Bic other = sh_bic[th + (1u << i)];
            bic = bic_combine(bic, other);
        }
        barrier();
        sh_bic[th] = bic;
    }

    // reverse scan of "bottom of stack" values
    barrier();
    uint next_bic_b = th + 1 == WG_SIZE ? 0 : sh_bic[th + 1].b;
    vec4 bbox = bic.b == next_bic_b ? BBOX_IDENTITY : stack[th * PART_SIZE].bbox;
    for (uint i = 0; i < LG_WG_SIZE; i++) {
        sh_bbox[th] = bbox;
        barrier();
        if (th + (1u << i) < WG_SIZE) {
            bbox = bbox_union(bbox, sh_bbox[th + (1u << i)]);
        }
        barrier();
    }
    sh_bbox[th] = bbox;
    barrier();
    // binary search in stack to do stream compaction
    uint sp = PART_SIZE - 1 - th;
    uint ix = 0;
    for (uint i = 0; i < LG_WG_SIZE; i++) {
        uint probe = ix + (uint(PART_SIZE / 2) >> i);
        if (sp < sh_bic[probe].b) {
            ix = probe;
        }
    }
    // ix is the largest value such that sp < sh_bic[ix].b (if any)
    uint b = sh_bic[ix].b;
    if (sp < b) {
        vec4 bbox = stack[ix * PART_SIZE + b - sp - 1];
        if (ix + 1 < WG_SIZE) {
            bbox = bbox_union(bbox, sh_bbox[ix + 1]);
        }
        sh_stack[th] = bbox;
    }

    // Do tree reduction of bicyclic semigroups and bounding boxes
    Node inp = inbuf[gl_GlobalInvocationID.x];
    uint node_type = inp.node_type;
    bic = Bic(uint(node_type == OPEN_PAREN), uint(node_type == CLOSE_PAREN));
    sh_bic[th] = bic;
    sh_bbox[th] = inp.bbox;
    uint inbase = 0;
    for (uint i = 0; i < LG_WG_SIZE - 1; i++) {
        uint outbase = 2 * WG_SIZE - (1u << (LG_WG_SIZE - i));
        barrier();
        if (th < (1u << (LG_WG_SIZE - 1 - i))) {
            sh_bic[outbase + th] = bic_combine(sh_bic[inbase + th * 2], sh_bic[inbase + th * 2 + 1]);
            sh_bbox[outbase + th] = bbox_union(sh_bbox[inbase + th * 2], sh_bbox[inbase + th * 2 + 1]);
        }
        inbase = outbase;
    }

    // Search for predecessor node and aggregate bounding boxes
    ix = th;
    bbox = BBOX_IDENTITY;
    uint j = 0;
    while (j < LG_WG_SIZE) {
        uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
        if (((ix >> j) & 1) != 0) {
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b > 0) {
                break;
            }
            bic = test;
            bbox = bbox_union(sh_bbox[base + (ix >> j) - 1], bbox);
            ix -= 1u << j;
        }
        j++;
    }
    if (ix > 0) {
        while (j > 0) {
            j--;
            uint base = 2 * WG_SIZE - (2u << (LG_WG_SIZE - j));
            Bic test = bic_combine(sh_bic[base + (ix >> j) - 1], bic);
            if (test.b == 0) {
                bic = test;
                bbox = bbox_union(sh_bbox[base + (ix >> j) - 1], bbox);
                ix -= 1u << j;
            }
        }
    }
    // ix is the smallest value such that reduce(ix..th).b == 0
    if (ix == 0) {
        bbox = bbox_union(sh_stack[PART_SIZE - 1 - bic.a], bbox);
    }
    outbuf[th] = bbox;
}
